; Michael Gyarmathy
; CSCE 420 - 500
; Instructor: Ronnie Ward
; eightpuzzle.lsp


; === Node ===
; ( '(configuration) depth action action_list <heuristic_value> )
; configuration : (1 2 3 4 5 6 7 8 0)
; depth : 0
; action : U=UP R=RIGHT D=DOWN L=LEFT 0=ROOT
; action_list : (U D R L)
; heuristic_value : h(node)


; Globals
; set limit to 10 for easy/medium problems
(defvar *search_depth_limit* 10)
; set limit to 31 for hard problems
;(defvar *search_depth_limit* 31)
; maximum number needed to solve is 31 (according to: cs.princeton.edu)


; DFS -- Algorithm (iterative version)
(defun dfs (start-state)
   (let (cur-node node-list (goal-found NIL) (largest-list 0))
      (setq node-list (list (make-root-node start-state)))
      (loop (unless (equal goal-found T))
         (if (> (length node-list) largest-list) (setq largest-list (length node-list)))
         (if (< (length node-list) 1) (return-from dfs nil))
         (setq cur-node (car node-list))
         (setq node-list (cdr node-list))
         ; debug (print cur-node)
         (if (goalp cur-node)
            (let ((action_sequence (fourth cur-node)))
               ; reverse final sequence of actions
               (setf (fourth cur-node) (reverse action_sequence))
               (format t "~%Solution Move Sequence: ~S~%" (fourth cur-node))
               (format t "Goal Node Depth: ~S~%" (second cur-node))
               (format t "Largest Node List Size: ~S~%" largest-list)
               (return-from dfs cur-node)
            )
            ;else -- check depth of node
            (if (< (second cur-node) *search_depth_limit*)
               (setq node-list (append (expand cur-node node-list) node-list))
            )
         )
      )
   )
)

; Greedy -- Algorithm
(defun greedy (start-state heuristic_fn)
   (let (cur-node node-list (goal-found NIL) (largest-list 0))
      (setq node-list (assign_greedy_heuristic (list (make-root-node start-state)) heuristic_fn))
      (loop (unless (equal goal-found T))
         (if (> (length node-list) largest-list) (setq largest-list (length node-list)))
         (if (< (length node-list) 1) (return-from greedy nil))
         (setq cur-node (car node-list))
         (setq node-list (cdr node-list))
         ; debug (print cur-node)
         (if (goalp cur-node)
            (let ((action_sequence (fourth cur-node)))
               ; reverse final sequence of actions
               (setf (fourth cur-node) (reverse action_sequence))
               (format t "~%Solution Move Sequence: ~S~%" (fourth cur-node))
               (format t "Goal Node Depth: ~S~%" (second cur-node))
               (format t "Largest Node List Size: ~S~%" largest-list)
               (return-from greedy cur-node)
            )
            ;else -- check depth of node
            (if (< (second cur-node) *search_depth_limit*)
               (progn
                  (setq node-list (append (assign_greedy_heuristic (expand cur-node node-list) heuristic_fn) node-list))
                  (setq node-list (reorder node-list))
               )
            )
         )
      )
   )
)

; A-Star -- Algorithm
(defun a_star (start-state heuristic_fn)
   (let (cur-node node-list (goal-found NIL) (largest-list 0))
      (setq node-list (assign_astar_heuristic (list (make-root-node start-state)) heuristic_fn))
      (loop (unless (equal goal-found T))
         (if (> (length node-list) largest-list) (setq largest-list (length node-list)))
         (if (< (length node-list) 1) (return-from a_star nil))
         (setq cur-node (car node-list))
         (setq node-list (cdr node-list))
         ; debug (print cur-node)
         (if (goalp cur-node)
            (let ((action_sequence (fourth cur-node)))
               ; reverse final sequence of actions
               (setf (fourth cur-node) (reverse action_sequence))
               (format t "~%Solution Move Sequence: ~S~%" (fourth cur-node))
               (format t "Goal Node Depth: ~S~%" (second cur-node))
               (format t "Largest Node List Size: ~S~%" largest-list)
               (return-from a_star cur-node)
            )
            ;else -- check depth of node
            (if (< (second cur-node) *search_depth_limit*)
               (progn
                  (setq node-list (append (assign_astar_heuristic (expand cur-node node-list) heuristic_fn) node-list))
                  (setq node-list (reorder node-list))
               )
            )
         )
      )
   )
)

; expand -- generate list of nodes from possible moves
; check previous move to prevent redundant moves
(defun expand (node node-list)
   (let ((expand-list) (tiles (first node)) (last-move (third node)))
      (if (= 0 (first tiles))
         (let ((right (move_right node))
               (down (move_down node))
            )
            (if (and (not (dupe right node-list)) (not (equal last-move 'L)))
               (setq expand-list (cons right expand-list))
            )
            (if (and (not (dupe down node-list)) (not (equal last-move 'U)))
               (setq expand-list (cons down expand-list))
            )
         )
      )
      (if (= 0 (second tiles))
         (let ((left (move_left node))
               (right (move_right node))
               (down (move_down node))
            )
            (if (and (not (dupe left node-list)) (not (equal last-move 'R)))
               (setq expand-list (cons left expand-list))
            )
            (if (and (not (dupe right node-list)) (not (equal last-move 'L)))
               (setq expand-list (cons right expand-list))
            )
            (if (and (not (dupe down node-list)) (not (equal last-move 'U)))
               (setq expand-list (cons down expand-list))
            )
         )
      )
      (if (= 0 (third tiles))
         (let ((left (move_left node))
               (down (move_down node))
            )
            (if (and (not (dupe left node-list)) (not (equal last-move 'R)))
               (setq expand-list (cons left expand-list))
            )
            (if (and (not (dupe down node-list)) (not (equal last-move 'U)))
               (setq expand-list (cons down expand-list))
            )
         )
      )
      (if (= 0 (fourth tiles))
         (let ((up (move_up node))
               (right (move_right node))
               (down (move_down node))
            )
            (if (and (not (dupe up node-list)) (not (equal last-move 'D)))
               (setq expand-list (cons up expand-list))
            )
            (if (and (not (dupe right node-list)) (not (equal last-move 'L)))
               (setq expand-list (cons right expand-list))
            )
            (if (and (not (dupe down node-list)) (not (equal last-move 'U)))
               (setq expand-list (cons down expand-list))
            )
         )
      )
      (if (= 0 (fifth tiles))
         (let ((up (move_up node))
               (right (move_right node))
               (down (move_down node))
               (left (move_left node))
            )
            (if (and (not (dupe up node-list)) (not (equal last-move 'D)))
               (setq expand-list (cons up expand-list))
            )
            (if (and (not (dupe right node-list)) (not (equal last-move 'L)))
               (setq expand-list (cons right expand-list))
            )
            (if (and (not (dupe down node-list)) (not (equal last-move 'U)))
               (setq expand-list (cons down expand-list))
            )
            (if (and (not (dupe left node-list)) (not (equal last-move 'R)))
               (setq expand-list (cons left expand-list))
            )
         )
      )
      (if (= 0 (sixth tiles))
         (let ((up (move_up node))
               (down (move_down node))
               (left (move_left node))
            )
            (if (and (not (dupe up node-list)) (not (equal last-move 'D)))
               (setq expand-list (cons up expand-list))
            )
            (if (and (not (dupe down node-list)) (not (equal last-move 'U)))
               (setq expand-list (cons down expand-list))
            )
            (if (and (not (dupe left node-list)) (not (equal last-move 'R)))
               (setq expand-list (cons left expand-list))
            )
         )
      )
      (if (= 0 (seventh tiles))
         (let ((up (move_up node))
               (right (move_right node))
            )
            (if (and (not (dupe up node-list)) (not (equal last-move 'D)))
               (setq expand-list (cons up expand-list))
            )
            (if (and (not (dupe right node-list)) (not (equal last-move 'L)))
               (setq expand-list (cons right expand-list))
            )
         )
      )
      (if (= 0 (eighth tiles))
         (let ((up (move_up node))
               (right (move_right node))
               (left (move_left node))
            )
            (if (and (not (dupe up node-list)) (not (equal last-move 'D)))
               (setq expand-list (cons up expand-list))
            )
            (if (and (not (dupe right node-list)) (not (equal last-move 'L)))
               (setq expand-list (cons right expand-list))
            )
            (if (and (not (dupe left node-list)) (not (equal last-move 'R)))
               (setq expand-list (cons left expand-list))
            )
         )
      )
      (if (= 0 (ninth tiles))
         (let ((up (move_up node))
               (left (move_left node))
            )
            (if (and (not (dupe up node-list)) (not (equal last-move 'D)))
               (setq expand-list (cons up expand-list))
            )
            (if (and (not (dupe left node-list)) (not (equal last-move 'R)))
               (setq expand-list (cons left expand-list))
            )
         )
      )
      ; shuffle list to avoid R-D-L-U loops (or U-D / L-R loops)
      (shuffle expand-list)
   )
)

; heuristic_1 -- number of tiles out-of-place
(defun heuristic_1 (node)
   (let ((h 0) (tiles (first node)))
      (if (not (= 1 (first tiles))) (incf h) )
      (if (not (= 2 (second tiles))) (incf h) )
      (if (not (= 3 (third tiles))) (incf h) )
      (if (not (= 8 (fourth tiles))) (incf h) )
      (if (not (= 0 (fifth tiles))) (incf h) )
      (if (not (= 4 (sixth tiles))) (incf h) )
      (if (not (= 7 (seventh tiles))) (incf h) )
      (if (not (= 6 (eighth tiles))) (incf h) )
      (if (not (= 5 (ninth tiles))) (incf h) )
   ;return
      h
   )
)

; heuristic_2 -- manhattan distance of all tiles from correct position
(defun heuristic_2 (node)
   (let ((total 0) (tiles (first node)))
      (loop
         for index from 0 to 8
         for val in tiles
         do (setq total (+ total (manhattan_distance index val)))
      )
      total
   )
)

; manhattan_distance -- compute the manhattan distance of a tile
; from where it is to its correct location
(defun manhattan_distance (index val)
   (+ (xdiff index val) (ydiff index val))
)

(defun xdiff (index val)
   (abs (- (xcoord index) (correct_xcoord val)))
)

(defun ydiff (index val)
   (abs (- (ycoord index) (correct_ycoord val)))
)

(defun xcoord (index)
   (cond
      ( (= index 0) 1)
      ( (= index 1) 2)
      ( (= index 2) 3)
      ( (= index 3) 1)
      ( (= index 4) 2)
      ( (= index 5) 3)
      ( (= index 6) 1)
      ( (= index 7) 2)
      ( (= index 8) 3)
   )
)

(defun ycoord (index)
   (cond
      ( (= index 0) 1)
      ( (= index 1) 1)
      ( (= index 2) 1)
      ( (= index 3) 2)
      ( (= index 4) 2)
      ( (= index 5) 2)
      ( (= index 6) 3)
      ( (= index 7) 3)
      ( (= index 8) 3)
   )
)

(defun correct_xcoord (val)
   (cond
      ( (= val 1) 1)
      ( (= val 2) 2)
      ( (= val 3) 3)
      ( (= val 8) 1)
      ( (= val 0) 2)
      ( (= val 4) 3)
      ( (= val 7) 1)
      ( (= val 6) 2)
      ( (= val 5) 3)
   )
)

(defun correct_ycoord (val)
   (cond
      ( (= val 1) 1)
      ( (= val 2) 1)
      ( (= val 3) 1)
      ( (= val 8) 2)
      ( (= val 0) 2)
      ( (= val 4) 2)
      ( (= val 7) 3)
      ( (= val 6) 3)
      ( (= val 5) 3)
   )
)

; move_* functions -- given a node, make a copy and perform a move
(defun move_up (node)
   (let* ((n (copy-tree node))
         (tiles (first n))
         (action_list (fourth n))
         )
      (cond
         ((= (fourth tiles) 0)
            (let ((x (first tiles)))
                  (setf (first tiles) 0)
                  (setf (fourth tiles) x)
            )
         )
         ((= (fifth tiles) 0)
            (let ((x (second tiles)))
                  (setf (second tiles) 0)
                  (setf (fifth tiles) x)
            )
         )
         ((= (sixth tiles) 0)
            (let ((x (third tiles)))
                  (setf (third tiles) 0)
                  (setf (sixth tiles) x)
            )
         )
         ((= (seventh tiles) 0)
            (let ((x (fourth tiles)))
                  (setf (fourth tiles) 0)
                  (setf (seventh tiles) x)
            )
         )
         ((= (eighth tiles) 0)
            (let ((x (fifth tiles)))
                  (setf (fifth tiles) 0)
                  (setf (eighth tiles) x)
            )
         )
         ((= (ninth tiles) 0)
            (let ((x (sixth tiles)))
               (setf (sixth tiles) 0)
               (setf (ninth tiles) x)
            )
         )
      )
      (setf (first n) tiles)
      (setf (second n) (+ 1 (second n)))
      (setf (third n) 'U)
      (setf (fourth n) (cons 'U action_list))
      n
   )
)

(defun move_right (node)
   (let* ((n (copy-tree node))
         (tiles (first n))
         (action_list (fourth n))
         )
      (cond
         ((= (first tiles) 0)
            (let ((x (second tiles)))
                  (setf (second tiles) 0)
                  (setf (first tiles) x)
            )
         )
         ((= (second tiles) 0)
            (let ((x (third tiles)))
                  (setf (third tiles) 0)
                  (setf (second tiles) x)
            )
         )
         ((= (fourth tiles) 0)
            (let ((x (fifth tiles)))
                  (setf (fifth tiles) 0)
                  (setf (fourth tiles) x)
            )
         )
         ((= (fifth tiles) 0)
            (let ((x (sixth tiles)))
                  (setf (sixth tiles) 0)
                  (setf (fifth tiles) x)
            )
         )
         ((= (seventh tiles) 0)
            (let ((x (eighth tiles)))
                  (setf (eighth tiles) 0)
                  (setf (seventh tiles) x)
            )
         )
         ((= (eighth tiles) 0)
            (let ((x (ninth tiles)))
               (setf (ninth tiles) 0)
               (setf (eighth tiles) x)
            )
         )
      )
      (setf (first n) tiles)
      (setf (second n) (+ 1 (second n)))
      (setf (third n) 'R)
      (setf (fourth n) (cons 'R action_list ))
      n
   )
)

(defun move_down (node)
   (let* ((n (copy-tree node))
         (tiles (first n))
         (action_list (fourth n))
         )
      (cond
         ((= (first tiles) 0)
            (let ((x (fourth tiles)))
                  (setf (fourth tiles) 0)
                  (setf (first tiles) x)
            )
         )
         ((= (second tiles) 0)
            (let ((x (fifth tiles)))
                  (setf (fifth tiles) 0)
                  (setf (second tiles) x)
            )
         )
         ((= (third tiles) 0)
            (let ((x (sixth tiles)))
                  (setf (sixth tiles) 0)
                  (setf (third tiles) x)
            )
         )
         ((= (fourth tiles) 0)
            (let ((x (seventh tiles)))
                  (setf (seventh tiles) 0)
                  (setf (fourth tiles) x)
            )
         )
         ((= (fifth tiles) 0)
            (let ((x (eighth tiles)))
                  (setf (eighth tiles) 0)
                  (setf (fifth tiles) x)
            )
         )
         ((= (sixth tiles) 0)
            (let ((x (ninth tiles)))
               (setf (ninth tiles) 0)
               (setf (sixth tiles) x)
            )
         )
      )
      (setf (first n) tiles)
      (setf (second n) (+ 1 (second n)))
      (setf (third n) 'D)
      (setf (fourth n) (cons 'D action_list))
      n
   )
)

(defun move_left (node)
   (let* ((n (copy-tree node))
         (tiles (first n))
         (action_list (fourth n))
         )
      (cond
         ((= (second tiles) 0)
            (let ((x (first tiles)))
                  (setf (first tiles) 0)
                  (setf (second tiles) x)
            )
         )
         ((= (third tiles) 0)
            (let ((x (second tiles)))
                  (setf (second tiles) 0)
                  (setf (third tiles) x)
            )
         )
         ((= (fifth tiles) 0)
            (let ((x (fourth tiles)))
                  (setf (fourth tiles) 0)
                  (setf (fifth tiles) x)
            )
         )
         ((= (sixth tiles) 0)
            (let ((x (fifth tiles)))
                  (setf (fifth tiles) 0)
                  (setf (sixth tiles) x)
            )
         )
         ((= (eighth tiles) 0)
            (let ((x (seventh tiles)))
                  (setf (seventh tiles) 0)
                  (setf (eighth tiles) x)
            )
         )
         ((= (ninth tiles) 0)
            (let ((x (eighth tiles)))
               (setf (eighth tiles) 0)
               (setf (ninth tiles) x)
            )
         )
      )
      (setf (first n) tiles)
      (setf (second n) (+ 1 (second n)))
      (setf (third n) 'L)
      (setf (fourth n) (cons 'L action_list))
      n
   )
)

; goal check
(defun goalp (node)
   (equal (first node) '(1 2 3 8 0 4 7 6 5))
)

; make root node
(defun make-root-node (initial_Configuration)
   (list initial_Configuration 0 0 ())
)

; check node list for duplicate states
(defun dupe (node node-list)
   (let ((state (first node)))
      (dolist (n node-list NIL)
         (if (equal state (first n))
            (return-from dupe T)
         )
      )
   )
)

; assign_greedy_heuristic -- given a list of nodes, create a new list with ( (n h(n)) (n h(n) ...)
(defun assign_greedy_heuristic (node-list heuristic_fn)
   (let (heuristic-list)
      (dolist (node node-list)
         (if (= (length node) 5)
            (progn
               (setf (fifth node) (funcall heuristic_fn node))
               (setq heuristic-list (cons node heuristic-list))
            )
            ;else -- append heuristic value to end of node
            (setq heuristic-list (cons (reverse (cons (funcall heuristic_fn node) (reverse node))) heuristic-list))
         )
      )
      heuristic-list
   )
)

; assign_heuristic -- given a list of nodes, create a new list with ( (n h(n)) (n h(n) ...)
(defun assign_astar_heuristic (node-list heuristic_fn)
   (let (heuristic-list)
      (dolist (node node-list)
         (if (= (length node) 5)
            (progn
               (setf (fifth node) (+ (second node) (funcall heuristic_fn node)))
               (setq heuristic-list (cons node heuristic-list))
            )
            ;else -- append heuristic value to end of node
            (setq heuristic-list (cons (reverse (cons (+ (second node) (funcall heuristic_fn node)) (reverse node))) heuristic-list))
         )
      )
      heuristic-list
   )
)

; reorder -- sort a list of nodes by heuristic values
; usage: (setq node-list (reorder node-list))
(defun reorder (node-list)
   (let ((sorted-list (copy-tree node-list)))
      (setq node-list (sort sorted-list #'(lambda (x y) (< (fifth x) (fifth y)) )))
      (copy-tree node-list)
   )
)

; shuffle -- shuffle the order of a list
(defun shuffle (seq)
   (let ((n (length seq)))
      (dotimes (i n seq)
         (rotatef (elt seq i)(elt seq (+ i (random (- n i)))))
      )
   )
)

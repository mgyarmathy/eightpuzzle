; Michael Gyarmathy
; CSCE 420 - 500
; Instructor: Ronnie Ward
; eightpuzzle.lsp


; === Node ===
; ( '(configuration) depth action action_list <heuristic_value>)
; configuration : (1 2 3 4 5 6 7 8 0)
; depth : 0
; action : U=UP R=RIGHT D=DOWN L=LEFT 0=ROOT
; action_list : (U D R L)
; heuristic_value : h(node)


; Globals
(defvar *search_depth_limit* 10) ; maximum number needed to solve is 31 (according to: cs.princeton.edu)
;; set limit to 5 for easy problems, and 10 for medium problems...not sure about hard yet. (try 15-20)


; DFS -- Algorithm
(defun dfs (initial_Configuration)
   (dfs-iter initial_Configuration)
)


; dfs-iter: iterative version of dfs
(defun dfs-iter (start-state)
   (let (cur-node node-list (goal-found NIL) (largest-list 0))
      (setq node-list (list (make-root-node start-state)))
      (loop (unless (equal goal-found T))
         ;(print node-list)
         (if (> (length node-list) largest-list) (setq largest-list (length node-list)))
         (if (< (length node-list) 1) (return-from dfs-iter nil))
         (setq cur-node (car node-list))
         (setq node-list (cdr node-list))
         (if (goalp cur-node)
            (let ((action_sequence (fourth cur-node)))
               ; reverse final sequence of actions
               (setf (fourth cur-node) (reverse action_sequence))
               (print largest-list)
               (return-from dfs-iter cur-node)
            )
            ;else
            (if (< (second cur-node) *search_depth_limit*)
               (setq node-list (append (expand cur-node node-list) node-list))
            )
         )
      )
   )
)

; Greedy -- Algorithm
(defun greedy (start-state heuristic_fn)
   (let (cur-node node-list (goal-found NIL) (largest-list 0))
      (setq node-list (assign_greedy_heuristic (list (make-root-node start-state)) heuristic_fn))
      (loop (unless (equal goal-found T))
         (if (> (length node-list) largest-list) (setq largest-list (length node-list)))
         (if (< (length node-list) 1) (return-from greedy nil))
         (setq cur-node (car node-list))
         (setq node-list (cdr node-list))
         (if (goalp cur-node)
            (let ((action_sequence (fourth cur-node)))
               ; reverse final sequence of actions
               (setf (fourth cur-node) (reverse action_sequence))
               (print largest-list)
               (return-from greedy cur-node)
            )
            ;else -- check depth of node
            (if (< (second cur-node) *search_depth_limit*)
               (progn
                  (setq node-list (append (assign_greedy_heuristic (expand cur-node node-list) heuristic_fn) node-list))
                  (setq node-list (reorder node-list))
               )
            )
         )
      )
   )
)

; A-Star -- Algorithm
(defun a_star (start-state heuristic_fn)
   (let (cur-node node-list (goal-found NIL) (largest-list 0))
      (setq node-list (assign_astar_heuristic (list (make-root-node start-state)) heuristic_fn))
      (loop (unless (equal goal-found T))
         (if (> (length node-list) largest-list) (setq largest-list (length node-list)))
         (if (< (length node-list) 1) (return-from a_star nil))
         (setq cur-node (car node-list))
         (setq node-list (cdr node-list))
         (if (goalp cur-node)
            (let ((action_sequence (fourth cur-node)))
               ; reverse final sequence of actions
               (setf (fourth cur-node) (reverse action_sequence))
               (print largest-list)
               (return-from a_star cur-node)
            )
            ;else -- check depth of node
            ;(if (< (second (first cur-node)) *search_depth_limit*)
               (progn
                  (setq node-list (append (assign_astar_heuristic (expand cur-node node-list) heuristic_fn) node-list))
                  (setq node-list (reorder node-list))
               )
            ;)
         )
      )
   )
)

; expand -- generate list of nodes from possible moves
(defun expand (node node-list)
   (let ((expand-list) (tiles (first node)))
      (if (= 0 (first tiles))
         (let ((right (move_right node))
               (down (move_down node))
            )
            (if (not (dupe right node-list))
               (setq expand-list (cons right expand-list))
            )
            (if (not (dupe down node-list))
               (setq expand-list (cons down expand-list))
            )
         )
      )
      (if (= 0 (second tiles))
         (let ((left (move_left node))
               (right (move_right node))
               (down (move_down node))
            )
            (if (not (dupe left node-list))
               (setq expand-list (cons left expand-list))
            )
            (if (not (dupe right node-list))
               (setq expand-list (cons right expand-list))
            )
            (if (not (dupe down node-list))
               (setq expand-list (cons down expand-list))
            )
         )
      )
      (if (= 0 (third tiles))
         (let ((left (move_left node))
               (down (move_down node))
            )
            (if (not (dupe left node-list))
               (setq expand-list (cons left expand-list))
            )
            (if (not (dupe down node-list))
               (setq expand-list (cons down expand-list))
            )
         )
      )
      (if (= 0 (fourth tiles))
         (let ((up (move_up node))
               (right (move_right node))
               (down (move_down node))
            )
            (if (not (dupe up node-list))
               (setq expand-list (cons up expand-list))
            )
            (if (not (dupe right node-list))
               (setq expand-list (cons right expand-list))
            )
            (if (not (dupe down node-list))
               (setq expand-list (cons down expand-list))
            )
         )
      )
      (if (= 0 (fifth tiles))
         (let ((up (move_up node))
               (right (move_right node))
               (down (move_down node))
               (left (move_left node))
            )
            (if (not (dupe up node-list))
               (setq expand-list (cons up expand-list))
            )
            (if (not (dupe right node-list))
               (setq expand-list (cons right expand-list))
            )
            (if (not (dupe down node-list))
               (setq expand-list (cons down expand-list))
            )
            (if (not (dupe left node-list))
               (setq expand-list (cons left expand-list))
            )
         )
      )
      (if (= 0 (sixth tiles))
         (let ((up (move_up node))
               (down (move_down node))
               (left (move_left node))
            )
            (if (not (dupe up node-list))
               (setq expand-list (cons up expand-list))
            )
            (if (not (dupe down node-list))
               (setq expand-list (cons down expand-list))
            )
            (if (not (dupe left node-list))
               (setq expand-list (cons left expand-list))
            )
         )
      )
      (if (= 0 (seventh tiles))
         (let ((up (move_up node))
               (right (move_right node))
            )
            (if (not (dupe up node-list))
               (setq expand-list (cons up expand-list))
            )
            (if (not (dupe right node-list))
               (setq expand-list (cons right expand-list))
            )
         )
      )
      (if (= 0 (eighth tiles))
         (let ((up (move_up node))
               (right (move_right node))
               (left (move_left node))
            )
            (if (not (dupe up node-list))
               (setq expand-list (cons up expand-list))
            )
            (if (not (dupe right node-list))
               (setq expand-list (cons right expand-list))
            )
            (if (not (dupe left node-list))
               (setq expand-list (cons left expand-list))
            )
         )
      )
      (if (= 0 (ninth tiles))
         (let ((up (move_up node))
               (left (move_left node))
            )
            (if (not (dupe up node-list))
               (setq expand-list (cons up expand-list))
            )
            (if (not (dupe left node-list))
               (setq expand-list (cons left expand-list))
            )
         )
      )
      ; shuffle list to avoid R-D-L-U loops (or U-D / L-R loops)
      (shuffle expand-list)
   )
)

; heuristic_1 -- number of tiles out-of-place
(defun heuristic_1 (node)
   (setq tiles (first node))
   (let ((h 0))
      (if (not (= 1 (first tiles))) (incf h) )
      (if (not (= 2 (second tiles))) (incf h) )
      (if (not (= 3 (third tiles))) (incf h) )
      (if (not (= 8 (fourth tiles))) (incf h) )
      (if (not (= 0 (fifth tiles))) (incf h) )
      (if (not (= 4 (sixth tiles))) (incf h) )
      (if (not (= 7 (seventh tiles))) (incf h) )
      (if (not (= 6 (eighth tiles))) (incf h) )
      (if (not (= 5 (ninth tiles))) (incf h) )
   ;return
      h
   )
)

(defun move_up (node)
   (let* ((n (copy-tree node))
         (tiles (first n))
         (action_list (fourth n))
         )
      (cond
         ((= (fourth tiles) 0)
            (let ((x (first tiles)))
                  (setf (first tiles) 0)
                  (setf (fourth tiles) x)
            )
         )
         ((= (fifth tiles) 0)
            (let ((x (second tiles)))
                  (setf (second tiles) 0)
                  (setf (fifth tiles) x)
            )
         )
         ((= (sixth tiles) 0)
            (let ((x (third tiles)))
                  (setf (third tiles) 0)
                  (setf (sixth tiles) x)
            )
         )
         ((= (seventh tiles) 0)
            (let ((x (fourth tiles)))
                  (setf (fourth tiles) 0)
                  (setf (seventh tiles) x)
            )
         )
         ((= (eighth tiles) 0)
            (let ((x (fifth tiles)))
                  (setf (fifth tiles) 0)
                  (setf (eighth tiles) x)
            )
         )
         ((= (ninth tiles) 0)
            (let ((x (sixth tiles)))
               (setf (sixth tiles) 0)
               (setf (ninth tiles) x)
            )
         )
      )
      (setf (first n) tiles)
      (setf (second n) (+ 1 (second n)))
      (setf (third n) 'U)
      (setf (fourth n) (cons 'U action_list))
      n
   )
)

(defun move_right (node)
   (let* ((n (copy-tree node))
         (tiles (first n))
         (action_list (fourth n))
         )
      (cond
         ((= (first tiles) 0)
            (let ((x (second tiles)))
                  (setf (second tiles) 0)
                  (setf (first tiles) x)
            )
         )
         ((= (second tiles) 0)
            (let ((x (third tiles)))
                  (setf (third tiles) 0)
                  (setf (second tiles) x)
            )
         )
         ((= (fourth tiles) 0)
            (let ((x (fifth tiles)))
                  (setf (fifth tiles) 0)
                  (setf (fourth tiles) x)
            )
         )
         ((= (fifth tiles) 0)
            (let ((x (sixth tiles)))
                  (setf (sixth tiles) 0)
                  (setf (fifth tiles) x)
            )
         )
         ((= (seventh tiles) 0)
            (let ((x (eighth tiles)))
                  (setf (eighth tiles) 0)
                  (setf (seventh tiles) x)
            )
         )
         ((= (eighth tiles) 0)
            (let ((x (ninth tiles)))
               (setf (ninth tiles) 0)
               (setf (eighth tiles) x)
            )
         )
      )
      (setf (first n) tiles)
      (setf (second n) (+ 1 (second n)))
      (setf (third n) 'R)
      (setf (fourth n) (cons 'R action_list ))
      n
   )
)

(defun move_down (node)
   (let* ((n (copy-tree node))
         (tiles (first n))
         (action_list (fourth n))
         )
      (cond
         ((= (first tiles) 0)
            (let ((x (fourth tiles)))
                  (setf (fourth tiles) 0)
                  (setf (first tiles) x)
            )
         )
         ((= (second tiles) 0)
            (let ((x (fifth tiles)))
                  (setf (fifth tiles) 0)
                  (setf (second tiles) x)
            )
         )
         ((= (third tiles) 0)
            (let ((x (sixth tiles)))
                  (setf (sixth tiles) 0)
                  (setf (third tiles) x)
            )
         )
         ((= (fourth tiles) 0)
            (let ((x (seventh tiles)))
                  (setf (seventh tiles) 0)
                  (setf (fourth tiles) x)
            )
         )
         ((= (fifth tiles) 0)
            (let ((x (eighth tiles)))
                  (setf (eighth tiles) 0)
                  (setf (fifth tiles) x)
            )
         )
         ((= (sixth tiles) 0)
            (let ((x (ninth tiles)))
               (setf (ninth tiles) 0)
               (setf (sixth tiles) x)
            )
         )
      )
      (setf (first n) tiles)
      (setf (second n) (+ 1 (second n)))
      (setf (third n) 'D)
      (setf (fourth n) (cons 'D action_list))
      n
   )
)

(defun move_left (node)
   (let* ((n (copy-tree node))
         (tiles (first n))
         (action_list (fourth n))
         )
      (cond
         ((= (second tiles) 0)
            (let ((x (first tiles)))
                  (setf (first tiles) 0)
                  (setf (second tiles) x)
            )
         )
         ((= (third tiles) 0)
            (let ((x (second tiles)))
                  (setf (second tiles) 0)
                  (setf (third tiles) x)
            )
         )
         ((= (fifth tiles) 0)
            (let ((x (fourth tiles)))
                  (setf (fourth tiles) 0)
                  (setf (fifth tiles) x)
            )
         )
         ((= (sixth tiles) 0)
            (let ((x (fifth tiles)))
                  (setf (fifth tiles) 0)
                  (setf (sixth tiles) x)
            )
         )
         ((= (eighth tiles) 0)
            (let ((x (seventh tiles)))
                  (setf (seventh tiles) 0)
                  (setf (eighth tiles) x)
            )
         )
         ((= (ninth tiles) 0)
            (let ((x (eighth tiles)))
               (setf (eighth tiles) 0)
               (setf (ninth tiles) x)
            )
         )
      )
      (setf (first n) tiles)
      (setf (second n) (+ 1 (second n)))
      (setf (third n) 'L)
      (setf (fourth n) (cons 'L action_list))
      n
   )
)

; goal check
(defun goalp (node)
   (equal (first node) '(1 2 3 8 0 4 7 6 5))
)

; make root node
(defun make-root-node (initial_Configuration)
   (list initial_Configuration 0 0 ())
)

; make a node list
(defun make-node-list (state)
   (list state)
)

; check node list for duplicate states
(defun dupe (node node-list)
   (let ((state (first node)))
      (dolist (n node-list NIL)
         (if (equal state (first n))
            (return-from dupe T)
         )
      )
   )
)

; assign_greedy_heuristic -- given a list of nodes, create a new list with ( (n h(n)) (n h(n) ...)
(defun assign_greedy_heuristic (node-list heuristic_fn)
   (let (heuristic-list)
      (dolist (node node-list)
         (if (= (length node) 5)
            (progn
               (setf (fifth node) (funcall heuristic_fn node))
               (setq heuristic-list (cons node heuristic-list))
            )
            ;else -- append heuristic value to end of node
            (setq heuristic-list (cons (reverse (cons (funcall heuristic_fn node) (reverse node))) heuristic-list))
         )
      )
      heuristic-list
   )
)

; assign_heuristic -- given a list of nodes, create a new list with ( (n h(n)) (n h(n) ...)
(defun assign_astar_heuristic (node-list heuristic_fn)
   (let (heuristic-list)
      (dolist (node node-list)
         (if (= (length node) 5)
            (progn
               (setf (fifth node) (+ (second node) (funcall heuristic_fn node)))
               (setq heuristic-list (cons node heuristic-list))
            )
            ;else -- append heuristic value to end of node
            (setq heuristic-list (cons (reverse (cons (+ (second node) (funcall heuristic_fn node)) (reverse node))) heuristic-list))
         )
      )
      heuristic-list
   )
)

; sort a list of nodes with heuristic values
; (setq node-list (reorder node-list))
(defun reorder (node-list)
   (let ((sorted-list (copy-tree node-list)))
      (setq node-list (sort sorted-list #'(lambda (x y) (< (fifth x) (fifth y)) )))
      (copy-tree node-list)
   )
)

(defun shuffle (seq)
   (let ((n (length seq)))
      (dotimes (i n seq)
         (rotatef (elt seq i)(elt seq (+ i (random (- n i)))))
      )
   )
)
